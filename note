#single-number
remove appears twice number
1. %2
2. bitwise exclusive or operator(^)

#single-number-ii
remove appears 3 times number
1. %3
if using modulus operator(%), single-number and single-number-ii are same problem

#single-number-iii
every numbers occurs twice except two(x, y)
^ all number, get x^y
find mask: the first different bit of x,y
divide array into 2 groups using mask, every group change to single-number problem

#excel-sheet-column-title
1. (n-1)%26,(n-1)/26, NOT n%26,n/26
2. c++ algorithm: reverse
reverse return void
template <class BidirectionalIterator>
  void reverse (BidirectionalIterator first, BidirectionalIterator last);
3. c++ std::string operator+
std::operator+ (string)
string operator+ (const string& lhs, char          rhs);
string operator+ (char          lhs, const string& rhs);
both are ok:
  char   + string
  strint + char
code snippet:
  string s;
  s = char('A' + (n-1)%26) + s;

#factorial-trailing-zeroes
code snippet:
integer overflow because using multiply(*), use divide(/) instead
  int factor = 5;
  int count = 0;
  while (n > factor) {
    count += n/factor;
    factor *= 5;
  }

#majority-element
loop:
  get 2 element, if not same, drop
the remaining element is majority element.

#valid-parentheses
use stack

#two-sum
1. O(1) Space, O(nlogn) Time
  sort
  find 2 values(move in opposite direction, O(n))
  find index (bug: consider a==b)
    a+b=target
    if a==b:
      ...
    else:
      ...
2. O(n) Space, O(n) Time
  use hashmap: C++ is unordered_map

#implement-strstr
should be:
  pos <= limit
not:
  pos <  limit

#3sum-closest
sum=a+b+c
sum is closest to target
similar to 3sum
specify a, move b,c in opposite position

#4sum
i, j, m, n: all 4 index should rm duplicates

#compare-version-numbers
bug info:
1. tailing 0
  1.0 == 1
2. more than one '.'
  2.1.5.3 > 2.1

#permutations-ii
permutation + pruning
pruning: rm duplicate siblings

#generate-parentheses
1. pruning
the situation "the left '(' > the left ')'" is invalid
the situation: when used '(' == used ')', then choose a ')'
if (left > right) return;
2.
if (left > 0)
    helper(ret, s+'(', left-1, right);
if (right > 0)
    helper(ret, s+')', left, right-1);

#remove-nth-node-from-end-of-list
one pass key:
3 pointers: pre, cur, p
pre's next is cur
move p n steps first, than move pre and cur

#intersection-of-two-linked-lists
two linked list has intersection => two linked list has common part at tail
i              j                   k
* => * => * => * => * => * => * => *
               * => * => * => * => *
list1: i -> k
list2: j -> k
common part must within j -> k.
so move forward list1's head to j,
compare list1's head and list2's head iteratively
 
#find-peak-element
O(logN) algorithm, binary search
one pass:      O(N)
binary search: O(logN)

#rotate-image
rotate inplace
current impelementation is ugly

#min-stack
1. use 2 stack(Memory Limit Exceeded)
s1: all elements
s2: all current min element
  6 2
  4 2
  2 2
  3 3
  5 5
2.use 2 stack
s1: all elements
s2: min + counter(rm duplicate)
  6
  4
  2 2,3
  3 3,1
  5 5,1
3. use 2 stack
s1: all elements
s2: min(rm duplicate)
  6
  4
  2 2
  3 3
  5 5

#unique-paths
DP/Matrix DP
state:      path number from 0,0 to x,y
function:   f[x][y] = f[x-1][y] + f[x][y-1]
initialize: f[0][0] = 1
answer:     f[m-1][n-1]

#unique-paths-ii
DP/Matrix DP
unique-paths + obstacleGrid
state:      path number from 0,0 to x,y
function:
  if obstableGrid[x][y] == 0
    f[x][y] = f[x-1][y] + f[x][y-1]
  else if obstableGrid[x][y] == 1
    f[x][y] = 0
initialize:
  if obstacleGrid[0][0] == 0
    f[0][0] = 1
  else if obstacleGrid[0][0] == 1
    f[0][0] = 0
answer:     f[m-1][n-1]

#minimum-path-sum
DP/Matrix DP
state:      min path sum from 0,0 to x,y
function:   f[x][y] = min(f[x-1][y], f[x][y-1]) + grid[i][j]
initialize: f[0][0] = grid[0][0]
answer:     f[m-1][n-1]

#climbing-stairs
DP/Sequence DP
state:      f[x]: solution number from 1 to x
function:   f[x] = f[x-1] + f[x-2]
initialize: f[1] = 1
            f[2] = 2
answer:     f[n]

#jump-game
O(n) solution: move i from 0 to n-1, move jump_longest
DP
using DP will generate TLE, should optimize

#jump-game-ii
O(n) solution
  for (int i=0; i<n; ++i) {
    // the farest pos min_step can reach is cur_max_reach,
    // if i is larger than cur_max_reach => min_step can't reach i,
    // need one more step
    if (i > cur_max_reach) {
      cur_max_reach = next_max_reach;
      ++min_step;
    }
    next_max_reach = max(next_max_reach, i+A[i]);
  }

         i
arr:   { 2,    4,    1,    2,    0,    2,    1,    2 }
index:   0     1     2     3     4     5     6     7
         cur         next
               i
arr:   { 2,    4,    1,    2,    0,    2,    1,    2 }
index:   0     1     2     3     4     5     6     7
                     cur               next
                     i
arr:   { 2,    4,    1,    2,    0,    2,    1,    2 }
index:   0     1     2     3     4     5     6     7
                     cur               next
                           i
arr:   { 2,    4,    1,    2,    0,    2,    1,    2 }
index:   0     1     2     3     4     5     6     7
                                       cur
                                       next
                                 i
arr:   { 2,    4,    1,    2,    0,    2,    1,    2 }
index:   0     1     2     3     4     5     6     7
                                       cur
                                       next
                                       i
arr:   { 2,    4,    1,    2,    0,    2,    1,    2 }
index:   0     1     2     3     4     5     6     7
                                       cur         next
                                             i
arr:   { 2,    4,    1,    2,    0,    2,    1,    2 }
index:   0     1     2     3     4     5     6     7
                                                   cur
                                                   next
                                             i
arr:   { 2,    4,    1,    2,    0,    2,    1,    2 }
index:   0     1     2     3     4     5     6     7    8    9
                                                   cur       next

#palindrome-partitioning
dfs
dfs method more concise
dfs template need more exercise

#palindrome-partitioning-ii
DP/Sequence DP
state:      f[i]: the minimum cut numbers the string need. (the string build from the first i chars)
function:   f[i] = min(f[j] + 1, j<i&&substr[j+1,i] is palindrome)
initialize: f[i] = i - 1 (f[0] = -1)
answer:     f[s.size()]
using 2 dp
  // string s, n = s.size()
  // dp 1
  // f[i] = min(f[j] + 1, j<i&&substr[j+1,i] is palindrome)
  int f[n+1];
  f[0] = -1;
  // dp 2
  // palin[i][j] = false: substring [i,j] is NOT palindrome
  // palin[i][j] = true:  substring [i,j] is     palindrome
  bool palin[n][n];
  // the first i chars, at most cut to i parts, one char per part, use i-1 cuts
  f[i] = i - 1;
