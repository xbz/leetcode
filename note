#single-number
remove appears twice number
1. %2
2. bitwise exclusive or operator(^)

#single-number-ii
remove appears 3 times number
1. %3
if using modulus operator(%), single-number and single-number-ii are same problem

#single-number-iii
every numbers occurs twice except two(x, y)
^ all number, get x^y
find mask: the first different bit of x,y
divide array into 2 groups using mask, every group change to single-number problem

#excel-sheet-column-title
1. (n-1)%26,(n-1)/26, NOT n%26,n/26
2. c++ algorithm: reverse
reverse return void
template <class BidirectionalIterator>
  void reverse (BidirectionalIterator first, BidirectionalIterator last);
3. c++ std::string operator+
std::operator+ (string)
string operator+ (const string& lhs, char          rhs);
string operator+ (char          lhs, const string& rhs);
both are ok:
  char   + string
  strint + char
code snippet:
  string s;
  s = char('A' + (n-1)%26) + s;

#factorial-trailing-zeroes
code snippet:
integer overflow because using multiply(*), use divide(/) instead
  int factor = 5;
  int count = 0;
  while (n > factor) {
    count += n/factor;
    factor *= 5;
  }

#majority-element
loop:
  get 2 element, if not same, drop
the remaining element is majority element.

#valid-parentheses
use stack

#two-sum
1. O(1) Space, O(nlogn) Time
  sort
  find 2 values(move in opposite direction, O(n))
  find index (bug: consider a==b)
    a+b=target
    if a==b:
      ...
    else:
      ...
2. O(n) Space, O(n) Time
  use hashmap: C++ is unordered_map

#implement-strstr
should be:
  pos <= limit
not:
  pos <  limit

#3sum-closest
sum=a+b+c
sum is closest to target
similar to 3sum
specify a, move b,c in opposite position

#4sum
i, j, m, n: all 4 index should rm duplicates

#compare-version-numbers
bug info:
1. tailing 0
  1.0 == 1
2. more than one '.'
  2.1.5.3 > 2.1

#permutations-ii
permutation + pruning
pruning: rm duplicate siblings

#generate-parentheses
1. pruning
the situation "the left '(' > the left ')'" is invalid
the situation: when used '(' == used ')', then choose a ')'
if (left > right) return;
2.
if (left > 0)
    helper(ret, s+'(', left-1, right);
if (right > 0)
    helper(ret, s+')', left, right-1);

#remove-nth-node-from-end-of-list
one pass key:
3 pointers: pre, cur, p
pre's next is cur
move p n steps first, than move pre and cur

#intersection-of-two-linked-lists
two linked list has intersection => two linked list has common part at tail
i              j                   k
* => * => * => * => * => * => * => *
               * => * => * => * => *
list1: i -> k
list2: j -> k
common part must within j -> k.
so move forward list1's head to j,
compare list1's head and list2's head iteratively
 
#find-peak-element
O(logN) algorithm, binary search
one pass:      O(N)
binary search: O(logN)

#rotate-image
rotate inplace
current impelementation is ugly

#min-stack
1. use 2 stack(Memory Limit Exceeded)
s1: all elements
s2: all current min element
  6 2
  4 2
  2 2
  3 3
  5 5
2.use 2 stack
s1: all elements
s2: min + counter(rm duplicate)
  6
  4
  2 2,3
  3 3,1
  5 5,1
3. use 2 stack
s1: all elements
s2: min(rm duplicate)
  6
  4
  2 2
  3 3
  5 5

#unique-paths
DP/Matrix DP
state:      path number from 0,0 to x,y
function:   f[x][y] = f[x-1][y] + f[x][y-1]
initialize: f[0][0] = 1
answer:     f[n-1][m-1]

#unique-paths-ii
unique-paths + obstacleGrid
DP/Matrix DP
state:      path number from 0,0 to x,y
function:
  if obstableGrid[x][y] == 0
    f[x][y] = f[x-1][y] + f[x][y-1]
  else if obstableGrid[x][y] == 1
    f[x][y] = 0
initialize:
  if obstacleGrid[0][0] == 0
    f[0][0] = 1
  else if obstacleGrid[0][0] == 1
    f[0][0] = 0
answer:     f[n-1][m-1]
