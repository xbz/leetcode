single number
a^a = 0

single number 2
pattern:
every number appears three times means for every bit(0th, 1st, 2nd), sum the nth bit of every element of array, the result is multiple of 3.

permutations
1. dfs
2. swap

reverse integer
1. overflow
reverse 1000000009 or 2147483647(10 bits integer) will overflow
2. no need to use vector
using %10,/10 method, will get numbers in reverse order
3. x86_64(Ubuntu)
sizeof(int):      4
sizeof(long):     8
sizeof(long long):8

add two numbers
1. list2num, add num, num2list
  1.1. using reverse leads to overflow
  1.2. forget to process 0 to list: 0+0=0
  1.3. misunderstanding
  problem says: You are given two linked lists representing two non-negative numbers.
  i think non-negative number is unsigned int, it's wrong
2. add directly: list2list

add binary
1 and 2 is same
1.
  sum += a[i]-'0';
  i--;
2.
  sum += a[i--]-'0';

twosum
1. wrong submission:
code:
    vector<int> twoSum(vector<int> &numbers, int target) {
      vector<int> v(numbers.begin(), numbers.end());
      sort(v.begin(), v.end());
      size_t i = 0;
      size_t j = v.size() - 1;
      while (i < j) {
        if (v[i] + v[j] == target)
          break;
        else if (v[i] + v[j] < target)
          ++i;
        else
          --j;
      }
      // here
      int ind1 = find(numbers.begin(), numbers.end(), v[i]) - numbers.begin() + 1;
      int ind2 = find(numbers.begin(), numbers.end(), v[j]) - numbers.begin() + 1;
      vector<int> ret;
      ret.push_back(min(ind1, ind2));
      ret.push_back(max(ind1, ind2));
      return ret;
    }
fail case: [0,4,3,0], 0
on the failed case, ind1==ind2
when there are same numbers in testcase, find(num1) and find(num2) return same pos(the number appears first)
2. the unordered_map solution is wrong
unordered_map fails on same number testcase([0,4,3,0], 0)

plusone
bug:
problem requirement: compute n+1;
program implement: n+1...1(example, n=123, 123+111)
note:
in additon, carry can be not 1. carry can be 5678, it can be absorbed along the addition.

count and say
using helper i,j
11111222221
i
 j
11111222221
i
     j
11111222221
     i
     j
11111222221
     i
      j
11111222221
     i
          j
11111222221
          i
          j
11111222221
          i
           j
11111222221
           i
           j
string next(const string& s) {
  ostringstream ss;
  size_t i = 0;
  while (i < s.size()) {
    size_t j = i + 1;
    while (j<s.size() && s[i]==s[j])
      j++;
    ss << j-i << s[i];
    i = j;
  }
  return ss.str();
}

