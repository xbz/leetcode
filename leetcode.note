single number
a^a = 0

single number 2
pattern:
every number appears three times means for every bit(0th, 1st, 2nd), sum the nth bit of every element of array, the result is multiple of 3.

permutations
1. dfs
2. swap

reverse integer
1. overflow
reverse 1000000009 or 2147483647(10 bits integer) will overflow
2. no need to use vector
using %10,/10 method, will get numbers in reverse order
3. x86_64(Ubuntu)
sizeof(int):      4
sizeof(long):     8
sizeof(long long):8

add two numbers
1. list2num, add num, num2list
  1.1. using reverse leads to overflow
  1.2. forget to process 0 to list: 0+0=0
  1.3. misunderstanding
  problem says: You are given two linked lists representing two non-negative numbers.
  i think non-negative number is unsigned int, it's wrong
2. add directly: list2list

add binary
1 and 2 is same
1.
  sum += a[i]-'0';
  i--;
2.
  sum += a[i--]-'0';
